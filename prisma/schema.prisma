generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      Int                      @id @default(autoincrement())
  email                   String                   @unique
  password                String
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  lastLoginAt             DateTime?
  refreshToken            String?
  isEmailConfirmed        Boolean                  @default(false)
  isActive                Boolean                  @default(true)
  workouts                Workout[]
  exercises               Exercise[]
  personalRecords         PersonalRecord[]
  emailConfirmationTokens EmailConfirmationToken[]
  passwordResetTokens     PasswordResetToken[]
}

model DeletedUser {
  id             Int      @id @default(autoincrement())
  originalUserId Int
  email          String
  createdAt      DateTime
  deletedAt      DateTime @default(now())
}

model EmailConfirmationToken {
  id        Int       @id @default(autoincrement())
  token     String    @unique
  expiresAt DateTime
  createdAt DateTime  @default(now())
  usedAt    DateTime?
  isUsed    Boolean   @default(false)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int

  @@index([token])
  @@index([userId, isUsed])
}

model PasswordResetToken {
  id        Int       @id @default(autoincrement())
  token     String    @unique
  expiresAt DateTime
  createdAt DateTime  @default(now())
  usedAt    DateTime?
  isUsed    Boolean   @default(false)
  ipAddress String?
  userAgent String?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    Int

  @@index([token])
  @@index([userId, isUsed])
}

model Exercise {
  id                    Int               @id @default(autoincrement())
  name                  String
  user                  User?             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                Int?
  category              String            @default("strength") // strength cardio flexibility sports yoga etc..
  targetMuscleGroups    String[]          @default([])
  secondaryMuscleGroups String[]          @default([])
  equipment             String
  // level String?      beginner intermediate expert
  // mechanic String?   compound isolation
  // force String?      push pull 
  instructions          String?
  imageUrls             String[]          @default([])
  videoUrls             String[]          @default([])
  workoutExercises      WorkoutExercise[]
  personalRecords       PersonalRecord[]

  @@unique([name, userId, equipment])
}

model Workout {
  id                 Int               @id @default(autoincrement())
  title              String?
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  startedAt          DateTime          @default(now())
  completedAt        DateTime?
  activeDuration     Float             @default(0)
  status             WorkoutStatus     @default(DRAFT)
  notes              String?
  isPaused           Boolean           @default(false)
  pauseDuration      Float             @default(0)
  lastPauseStartTime DateTime?
  user               User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId             Int
  workoutExercises   WorkoutExercise[]
}

model WorkoutExercise {
  id                        Int               @id @default(autoincrement())
  workout                   Workout           @relation(fields: [workoutId], references: [id], onDelete: Cascade)
  workoutId                 Int
  exercise                  Exercise          @relation(fields: [exerciseId], references: [id], onDelete: Cascade)
  exerciseId                Int
  exerciseOrder             Int
  createdAt                 DateTime          @default(now())
  updatedAt                 DateTime          @updatedAt
  notes                     String?
  workoutSets               WorkoutSet[]
  previousWorkoutExercise   WorkoutExercise?  @relation("PreviousWorkoutExercise", fields: [previousWorkoutExerciseId], references: [id])
  previousWorkoutExerciseId Int?              @unique
  nextWorkoutExercise       WorkoutExercise?  @relation("PreviousWorkoutExercise")
}

model WorkoutSet {
  id                Int              @id @default(autoincrement())
  workoutExercise   WorkoutExercise  @relation(fields: [workoutExerciseId], references: [id], onDelete: Cascade)
  workoutExerciseId Int
  setNumber         Int
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  completed         Boolean          @default(false)
  notes             String?
  type              String           @default("normal")
  reps              Int?
  weight            Float?
  duration          Int?
  personalRecords   PersonalRecord[]
}

model PersonalRecord {
  id           Int        @id @default(autoincrement())
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       Int
  exercise     Exercise   @relation(fields: [exerciseId], references: [id], onDelete: Cascade)
  exerciseId   Int
  recordType   String
  createdAt    DateTime   @default(now())
  workoutSet   WorkoutSet @relation(fields: [workoutSetId], references: [id], onDelete: Cascade)
  workoutSetId Int

  @@unique([userId, exerciseId, recordType])
}

enum WorkoutStatus {
  ACTIVE
  DRAFT
  COMPLETED
}
